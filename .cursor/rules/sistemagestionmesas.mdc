---
alwaysApply: true
---
📋 GUÍA COMPLETA: Sistema de Gestión de Mesas CobroFácil
🎯 RESUMEN EJECUTIVO
Sistema integral de gestión de mesas para restaurantes que combina:
Gestión visual de sectores, mesas y objetos decorativos
Sistema de ventas con estados de mesa controlados
Facturación con formas de pago obligatorias
Arrastre y posicionamiento en tiempo real
Sincronización entre múltiples dispositivos
🏗️ ARQUITECTURA DEL SISTEMA
Componentes Principales
┌─────────────────────────────────────────────────────────────┐
│                    FRONTEND (React + TypeScript)           │
│  ┌─────────────────┐  ┌─────────────────┐                  │
│  │ GestionMesas    │  │ MesaGridCanvas  │                  │
│  │ (Coordinador)   │  │ (Renderizado)   │                  │
│  └─────────────────┘  └─────────────────┘                  │
│                                                             │
│  ┌─────────────────┐  ┌─────────────────┐                  │
│  │ VentaIntegralV2 │  │ FormularioObjs  │                  │
│  │ (Ventas/Factur.)│  │ (Objetos Decor.)│                  │
│  └─────────────────┘  └─────────────────┘                  │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ API REST
                              │
┌─────────────────────────────────────────────────────────────┐
│                    BACKEND (Node.js + Prisma)              │
│  ┌─────────────────┐  ┌─────────────────┐                  │
│  │ /api/sectores   │  │ /api/mesas      │                  │
│  │ /api/objetos    │  │ /api/ventas     │                  │
│  └─────────────────┘  └─────────────────┘                  │
│                                                             │
│  ┌─────────────────┐  ┌─────────────────┐                  │
│  │ PostgreSQL      │  │ Sistema Auth    │                  │
│  │ (Persistencia)  │  │ (JWT Tokens)    │                  │
│  └─────────────────┘  └─────────────────┘                  │
└─────────────────────────────────────────────────────────────┘
📊 ESTRUCTURA DE DATOS
Estados de Mesa (3 únicos)
enum EstadoMesa {
  LIBRE = 'LIBRE',                    // 🟢 Verde - Sin ítems ni facturación
  OCUPADA = 'OCUPADA',                // 🔴 Rojo - Con ítems, sin facturación
  ESPERANDO_PEDIDO = 'ESPERANDO_PEDIDO' // 🔵 Azul - Factura/ticket emitido
}
Modelo de Mesa
interface Mesa {
  id: string;
  numero: string;
  capacidad: number;
  posicionX: number;        // Coordenadas en canvas
  posicionY: number;
  size: number;            // Tamaño personalizable (20-200px)
  estado: EstadoMesa;
  forma: FormaMesa;        // REDONDA | CUADRADA | RECTANGULAR | OVALADA
  color?: string;
  sectorId: string;
  sector?: Sector;
}
Modelo de Facturación
interface FacturaEmitida {
  tipo: 'fiscal' | 'no_fiscal' | null;
  numero?: string;
  pagos: Array<{
    metodo: 'efectivo' | 'tarjeta' | 'qr' | 'transferencia';
    monto: number;
  }>;
  anulada: boolean;
  fechaEmision?: Date;
}
🎮 FUNCIONAMIENTO DETALLADO
1. GESTIÓN DE SECTORES
Crear Sector
// API: POST /api/sectores
{
  "nombre": "Salón Principal",
  "descripcion": "Área principal del restaurante",
  "color": "#2196f3",
  "icono": "🍽️",
  "orden": 0
}
Funcionalidades
Crear, editar, eliminar sectores
Ordenamiento por prioridad
Colores e iconos personalizables
Validación de nombres únicos
Crear Mesa
stateDiagram-v2
    [*] --> LIBRE
    LIBRE --> OCUPADA : Agregar ítem
    OCUPADA --> LIBRE : Eliminar todos los ítems
    OCUPADA --> ESPERANDO_PEDIDO : Emitir factura/ticket
    ESPERANDO_PEDIDO --> LIBRE : Completar venta
    ESPERANDO_PEDIDO --> OCUPADA : Anular factura
    Arrastre y Posicionamiento
Drag & Drop en tiempo real
Sistema de cambios pendientes (visual inmediato, guardado por lotes)
Sincronización automática entre dispositivos
Restricciones de límites del canvas
3. SISTEMA DE VENTAS
Flujo de Venta Completo
// API: POST /api/mesas
{
  "numero": "M01",
  "sectorId": "sector-id",
  "capacidad": 4,
  "forma": "REDONDA",
  "posicionX": 100,
  "posicionY": 150,
  "size": 60,
  "color": "#4caf50"
}
Estados de Venta
'activa' - Venta en curso
'enviada' - Comanda enviada a cocina
'cuenta_pedida' - Cuenta solicitada
Gestión de Productos
Búsqueda inteligente con normalización de texto
Modificación de cantidades en tiempo real
Eliminación con validación de estado
Especificaciones personalizadas por ítem
4. FACTURACIÓN Y FORMAS DE PAGO
Criterios Obligatorios
Registro obligatorio de forma de pago al emitir ticket
Estados únicos controlados por lógica de negocio
Anulación y reintegro con trazabilidad completa
Modal de Formas de Pago
// 1. Inicializar venta
ventasActivasService.crearVenta(mesa.id);

// 2. Agregar productos
ventasActivasService.agregarProducto(mesa.id, producto, cantidad);

// 3. Procesar facturación
const factura = await procesarFacturacionConPago(formasPago);

// 4. Completar venta
ventasActivasService.completarVenta(mesa.id);
Tipos de Comprobantes
TICKET - No fiscal
FACTURA_A - Responsable inscripto
FACTURA_B - Consumidor final
Proceso de Anulación
interface FormaPago {
  metodo: 'efectivo' | 'tarjeta' | 'qr' | 'transferencia';
  monto: number;
}

// Validación: Total de pagos = Total de venta
const totalPagos = formasPago.reduce((sum, p) => sum + p.monto, 0);
if (Math.abs(totalPagos - ventaTotal) > 0.01) {
  throw new Error('Los pagos deben cubrir el total');
}
5. OBJETOS DECORATIVOS
Tipos Disponibles
// Criterio 4: Lógica de anulación
const anularFactura = async () => {
  // 1. Anular ticket emitido
  setFacturaEmitida(prev => ({ ...prev, anulada: true }));
  
  // 2. Volver estado a rojo (ocupada)
  onCambiarEstado(mesa, EstadoMesa.OCUPADA);
  
  // 3. Permitir nueva facturación
  setModalFormasPago(true);
};
Crear Objeto
enum TipoObjeto {
  DECORATIVO = 'DECORATIVO',
  BARRA = 'BARRA',
  ESCENARIO = 'ESCENARIO',
  BANO = 'BANO',
  COCINA = 'COCINA',
  ENTRADA = 'ENTRADA',
  SALIDA = 'SALIDA',
  OTROS = 'OTROS'
}
Características
Arrastre igual que las mesas
Edición visual con iconos de ajuste ⚙️
Eliminación integrada en formulario
Sin iconos ni bordes (solo color de fondo)
6. SISTEMA DE CAMBIOS PENDIENTES
Arquitectura
Características
Arrastre igual que las mesas
Edición visual con iconos de ajuste ⚙️
Eliminación integrada en formulario
Sin iconos ni bordes (solo color de fondo)
6. SISTEMA DE CAMBIOS PENDIENTES
Arquitectura
Flujo de Guardado
interface CambiosPendientes {
  mesas: Array<{ id: string; posicionX: number; posicionY: number }>;
  objetos: Array<{ id: string; posicionX: number; posicionY: number }>;
}
7. SINCRONIZACIÓN INTELIGENTE
Lógica de Sincronización
// 1. Arrastre - Solo actualización visual
const handleMouseMove = (e) => {
  // Actualizar posición local inmediatamente
  setMesasLocales(prev => prev.map(mesa => 
    mesa.id === dragging.mesa.id 
      ? { ...mesa, posicionX: nuevaX, posicionY: nuevaY }
      : mesa
  ));
  
  // Registrar cambio pendiente (sin BD)
  setCambiosPendientes(prev => ({
    ...prev,
    mesas: [...prev.mesas.filter(m => m.id !== mesaId), 
           { id: mesaId, posicionX: nuevaX, posicionY: nuevaY }]
  }));
};

// 2. Guardado - Envío por lotes a BD
const guardarCambiosPendientes = async () => {
  for (const cambio of cambiosPendientes.mesas) {
    await mesasApi.actualizar(cambio.id, {
      posicionX: cambio.posicionX,
      posicionY: cambio.posicionY
    });
  }
  setCambiosPendientes({ mesas: [], objetos: [] });
};
8. MODO EDICIÓN
Activación
Botón "Editar Plano" en header
Atajo de teclado 'E'
Auto-activación al crear objetos
Funcionalidades
Arrastre de mesas y objetos
Iconos de ajuste ⚙️ para edición rápida
Grilla opcional (tecla 'G')
Zoom (Ctrl + rueda del mouse)
Guardado por lotes al salir
Atajos de Teclado
useEffect(() => {
  const tieneCambiosPendientes = cambiosPendientes.mesas.length > 0;
  
  // Solo sincronizar cuando:
  // 1. No hay cambios pendientes
  // 2. No se está arrastrando
  // 3. No estamos en modo edición con cambios
  if (!dragging && !tieneCambiosPendientes) {
    console.log('🔄 Sincronizando desde BD');
    setMesasLocales(mesas);
  } else {
    console.log('⏸️ Evitando sincronización - hay cambios pendientes');
  }
}, [mesas, dragging, cambiosPendientes]);
9. INTERFAZ DE USUARIO
Layout Principal
const atajos = {
  'E': 'Activar/desactivar modo edición',
  'G': 'Mostrar/ocultar grilla',
  'O': 'Crear objeto decorativo',
  'Ctrl++': 'Zoom in',
  'Ctrl+-': 'Zoom out',
  'Ctrl+0': 'Reset zoom',
  'Escape': 'Salir de modo edición'
};
Colores de Estado
🟢 Verde (#4CAF50) - Mesa libre
🔴 Rojo (#F44336) - Mesa ocupada
🔵 Azul (#2196F3) - Mesa facturada
10. APIs DEL BACKEND
┌─────────────────────────────────────────────────────────────┐
│ Header: Título + Botones (Nuevo Sector, Editar Plano)      │
├─────────────────────────────────────────────────────────────┤
│ Sectores: Tabs horizontales con colores e iconos           │
├─────────────────────────────────────────────────────────────┤
│ Sidebar │ Canvas Principal                                  │
│ - Ocup. │ - Mesas con estados de color                     │
│ - Stats │ - Objetos decorativos                            │
│         │ - Zoom y grilla opcionales                       │
└─────────────────────────────────────────────────────────────┘
Mesas
GET    /api/sectores          // Obtener todos
POST   /api/sectores          // Crear nuevo
PUT    /api/sectores/:id      // Actualizar
DELETE /api/sectores/:id      // Eliminar
Objetos Decorativos
GET    /api/mesas             // Obtener todas
POST   /api/mesas             // Crear nueva
PUT    /api/mesas/:id         // Actualizar
PATCH  /api/mesas/:id/estado  // Cambiar estado
PATCH  /api/mesas/:id/posicion // Actualizar posición
DELETE /api/mesas/:id         // Eliminar
11. VALIDACIONES Y SEGURIDAD
Autenticación
JWT Tokens en todas las rutas
Middleware verificarToken obligatorio
Manejo de expiración con redirección automática
Validaciones de Negocio
GET    /api/objetos-decorativos        // Obtener todos
POST   /api/objetos-decorativos        // Crear nuevo
PUT    /api/objetos-decorativos/:id    // Actualizar
PATCH  /api/objetos-decorativos/:id/posicion // Actualizar posición
DELETE /api/objetos-decorativos/:id    // Eliminar
12. RENDIMIENTO Y OPTIMIZACIÓN
Antes vs Después
// Estados de mesa
const validarCambioEstado = (estadoActual, estadoNuevo) => {
  // Solo se puede ir a AZUL desde ROJO con factura
  if (estadoNuevo === 'ESPERANDO_PEDIDO' && !facturaEmitida.tipo) {
    throw new Error('Debe emitir factura antes de cambiar a azul');
  }
};

// Formas de pago
const validarFormasPago = (formasPago, total) => {
  if (formasPago.length === 0) {
    throw new Error('Debe seleccionar al menos una forma de pago');
  }
  
  const totalPagos = formasPago.reduce((sum, p) => sum + p.monto, 0);
  if (Math.abs(totalPagos - total) > 0.01) {
    throw new Error('Los pagos deben cubrir el total exacto');
  }
};
Debounce y Throttling
❌ ANTES:
- 1 llamada API por píxel de arrastre
- Sincronización constante desde BD
- Pérdida de cambios al recargar

✅ DESPUÉS:
- 0 llamadas API durante arrastre
- Sincronización inteligente solo cuando es necesario
- Sistema de cambios pendientes con guardado por lotes
- Mejora del 95% en llamadas a BD
13. MANEJO DE ERRORES
Errores de Red
// Evitar spam de peticiones
const debouncedSave = useCallback(
  debounce((cambios) => {
    guardarCambiosPendientes(cambios);
  }, 300),
  []
);
Recuperación de Errores
Auto-retry en fallos de red
Reversión de cambios en caso de error
Notificaciones claras al usuario
Logs detallados para debugging
14. CASOS DE USO PRINCIPALES
Caso 1: Venta Completa
Cliente llega → Mesa en estado VERDE
Mesero agrega productos → Mesa cambia a ROJO
Cliente termina → Mesero emite ticket con forma de pago
Mesa cambia a AZUL → Venta completada
Cliente se va → Mesa vuelve a VERDE
Caso 2: Anulación de Factura
Mesa en estado AZUL (facturada)
Cliente quiere cambiar forma de pago
Mesero anula factura → Mesa vuelve a ROJO
Selecciona nueva forma de pago → Mesa vuelve a AZUL
Caso 3: Reorganización de Plano
Gerente activa modo edición
Arrastra mesas y objetos → Cambios visuales inmediatos
Botón muestra "Guardar Cambios (5)"
Hace clic en guardar → Todos los cambios se envían a BD
Desactiva modo edición → Cambios persistidos
15. MÉTRICAS Y MONITOREO
Logs de Operaciones
const handleError = (error) => {
  if (error.response?.status === 401) {
    // Token expirado
    localStorage.removeItem('authToken');
    window.location.href = '/login';
  } else if (error.response?.status === 409) {
    // Conflicto de datos
    mostrarNotificacion('Conflicto: datos ya modificados', 'warning');
    recargarDatos();
  } else {
    // Error genérico
    mostrarNotificacion('Error de conexión', 'error');
  }
};
Indicadores de Performance
Tiempo de respuesta de arrastre: < 16ms (60fps)
Reducción de API calls: 95%
Tiempo de guardado por lotes: < 2s
Sincronización entre dispositivos: < 5s
🎯 BENEFICIOS DEL SISTEMA
Para Operadores
Interfaz intuitiva con colores claros
Arrastre fluido sin delays
Estados automáticos sin intervención manual
Facturación obligatoria evita errores
Para Gerentes
Reorganización visual del plano
Reportes por forma de pago automáticos
Trazabilidad completa de operaciones
Sincronización entre múltiples dispositivos
Para Desarrolladores
Código modular y bien documentado
APIs RESTful estándar
Sistema de tipos completo en TypeScript
Manejo de errores robusto
🔧 CONFIGURACIÓN Y MANTENIMIENTO
Variables de Entorno
console.log('🎯 Moviendo mesa 3 (VISUAL):', {
  mousePos: { x: 250, y: 180 },
  nuevaPosicion: { x: 220, y: 150 },
  guardadoEn: 'PENDIENTE (no en BD)'
});

console.log('✅ Mesa guardada en BD:', mesaId, {
  x: nuevaPosicionX, 
  y: nuevaPosicionY
}, '(BD + estado)');
Backup y Restauración
# Backend
DATABASE_URL="postgresql://..."
JWT_SECRET="..."
NODE_ENV="production"

# Frontend
VITE_API_URL="http://localhost:3000"
VITE_APP_NAME="CobroFácil"
Mejoras Técnicas
WebSockets para sincronización en tiempo real
Service Workers para funcionamiento offline
Progressive Web App completa
Microservicios para escalabilidad